package org.codewars.morse;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.Arrays;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class MorseCodeDecoderTest {

    @Test
    void testDecode() {
        assertThat(MorseCodeDecoder.decodeMorse(".... . -.--   .--- ..- -.. .")).isEqualTo("HEY JUDE");
    }

    @Test
    void testSplitWords() {
        List<String> expected = Arrays.asList("....", ".", "-.--", "", ".---", "..-", "-..", ".");
        assertThat(MorseCodeDecoder.splitToWords(".... . -.--   .--- ..- -.. .")).isEqualTo(expected);
    }

    @ParameterizedTest
    @CsvSource(  value = {
            "01110,E"
            , "1,E"
            , "1100110011001100000011000000111111001100111111001111110000000000000011001111110011111100111111000000110011001111110000001111110011001100000011,HEY JUDE"
            , "111,E"
            , "111000000000111,EE"
            , "10001,EE"
    })
    public void testExampleFromDescription(String bits, String expected)  {
        assertThat(MorseCodeDecoder.decodeMorse(MorseCodeDecoder.decodeBits(bits))).isEqualTo(expected);
    }

    @ParameterizedTest
    @CsvSource(  value = {
            "0001110,111"
            , "1100,11"
            , "00111,111"
            , "00000000010101,10101"
    })
    void testStripExtraneousZeroes(String bits, String expected)  {
        assertThat(MorseCodeDecoder.stripExtraneousZeroes(bits)).isEqualTo(expected);
    }


//    "Dot" – is 1 time unit long.
//    "Dash" – is 3 time units long.
//    Pause between dots and dashes in a character – is 1 time unit long.
//    Pause between characters inside a word – is 3 time units long.
//    Pause between words – is 7 time units long.
    @ParameterizedTest
    @CsvSource(  value = {
            "10001,1",
            "101110001000000011101,1"
            ,"1100110011001100000011000000111111001100111111001111110000000000000011001111110011111100111111000000110011001111110000001111110011001100000011,2"
    })
    void testDetermineTimeUnit(String bits, int expected)  {
        assertThat(MorseCodeDecoder.determineTimeUnit(bits)).isEqualTo(expected);
    }

    @Test
    void testsplitStringOnChangeOfCharacter1()  {
        String input = "000000011100000";
        assertThat(MorseCodeDecoder.splitStringOnChangeOfCharacter(input))
                .containsExactlyInAnyOrder("0000000", "111", "00000");
    }

    @Test
    void testsplitStringOnChangeOfCharacter2()  {
        String input = "AAABCCCDD";
        assertThat(MorseCodeDecoder.splitStringOnChangeOfCharacter(input))
                .containsExactlyInAnyOrder("AAA", "B", "CCC", "DD");
    }

    @Test
    void testsplitStringOnChangeOfCharacter3()  {
        String input = "A";
        List<String> expected = Arrays.asList("A");
        assertThat(MorseCodeDecoder.splitStringOnChangeOfCharacter(input))
                .containsExactlyInAnyOrder("A");
    }
}

/*
>01110,
>000000011100000,
>1,
>101,
>10001,
>1100110011001100000011000000111111001100111111001111110000000000000011001111110011111100111111000000110011001111110000001111110011001100000011,
>00011100010101010001000000011101110101110001010111000101000111010111010001110101110000000111010101000101110100011101110111000101110111000111010000000101011101000111011101110001110101011100000001011101110111000101011100011101110001011101110100010101000000011101110111000101010111000100010111010000000111000101010100010000000101110101000101110001110111010100011101011101110000000111010100011101110111000111011101000101110101110101110,
>11111111111111100000000000000011111000001111100000111110000011111000000000000000111110000000000000000000000000000000000011111111111111100000111111111111111000001111100000111111111111111000000000000000111110000011111000001111111111111110000000000000001111100000111110000000000000001111111111111110000011111000001111111111111110000011111000000000000000111111111111111000001111100000111111111111111000000000000000000000000000000000001111111111111110000011111000001111100000111110000000000000001111100000111111111111111000001111100000000000000011111111111111100000111111111111111000001111111111111110000000000000001111100000111111111111111000001111111111111110000000000000001111111111111110000011111000000000000000000000000000000000001111100000111110000011111111111111100000111110000000000000001111111111111110000011111111111111100000111111111111111000000000000000111111111111111000001111100000111110000011111111111111100000000000000000000000000000000000111110000011111111111111100000111111111111111000001111111111111110000000000000001111100000111110000011111111111111100000000000000011111111111111100000111111111111111000000000000000111110000011111111111111100000111111111111111000001111100000000000000011111000001111100000111110000000000000000000000000000000000011111111111111100000111111111111111000001111111111111110000000000000001111100000111110000011111000001111111111111110000000000000001111100000000000000011111000001111111111111110000011111000000000000000000000000000000000001111111111111110000000000000001111100000111110000011111000001111100000000000000011111000000000000000000000000000000000001111100000111111111111111000001111100000111110000000000000001111100000111111111111111000000000000000111111111111111000001111111111111110000011111000001111100000000000000011111111111111100000111110000011111111111111100000111111111111111000000000000000000000000000000000001111111111111110000011111000001111100000000000000011111111111111100000111111111111111000001111111111111110000000000000001111111111111110000011111111111111100000111110000000000000001111100000111111111111111000001111100000111111111111111000001111100000111111111111111,
>111,
>1111111,
>110011,
>111000111,
>111110000011111,
>11111100111111,
>111000000000111,
 */